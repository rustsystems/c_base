===========================================================================
misc.Precedence:::OBJECT
    Variables: this this.i
this != null
this.i == 0 || this.i == 2 || this.i == 10
===========================================================================
misc.Precedence.Precedence():::EXIT
    Variables: this this.i
this.i == 0
===========================================================================
misc.Precedence.lets_calculate(int):::ENTER
    Variables: this this.i j
this.i == 10
j == 4
===========================================================================
misc.Precedence.lets_calculate(int):::EXIT
    Variables: this this.i j return orig(this) orig(this.i) orig(j)
assignable this.i
this.i == 2
\result == 6
===========================================================================
misc.Precedence.main(java.lang.String[]):::ENTER
    Variables: args args.getClass().getName() args[] args[].toString size(args[]) size(args[])-1
args != null
args.getClass().getName() == java.lang.String[].class.getName()
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(args, "toString()"), new String[] {  })
===========================================================================
misc.Precedence.main(java.lang.String[]):::EXIT
    Variables: args args.getClass().getName() args[] args[].toString orig(args) orig(args.getClass().getName()) orig(args[]) orig(args[].toString) size(args[]) size(args[])-1 orig(size(args[])) orig(size(args[]))-1
daikon.Quant.pairwiseEqual(args, \old(args))
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(args, "toString()"), new String[] {  })
